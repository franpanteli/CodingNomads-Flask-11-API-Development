-> introduction to testing your app lesson
  -> quick recap of python unit testing

-> contents
  -> introduction
  -> what is unit testing?
  -> pytest and unittest
  -> example test code
  -> testing with pytest
  -> summary: python flask unit testing

-> introduction
  -> in this section, you'll learn the basics of unit testing and how it applies to flask apps
  -> testing might seem like an extra task, but it's crucial for finding bugs before they become problems
  -> unit testing helps ensure that the individual components (functions, methods, etc.) of your application work correctly
  -> by catching issues early, testing saves time and reduces the risk of having serious bugs in production

-> what is unit testing?
  -> unit testing is a software testing method that focuses on testing individual units of source code to ensure they work as expected
  -> a "unit" typically refers to the smallest testable part of an application, like a function or method
  -> the purpose of unit tests is to check that each part of the code performs its intended function
  -> unit tests are written to verify if the functions or methods return correct results for given inputs
  -> the key idea is to isolate each unit and test it independently from the rest of the system
  -> if individual units pass their tests, you can be more confident that the application as a whole will function as expected
  -> unit testing prevents bugs in the early stages of development, helping to avoid future problems that might arise from faulty code
  -> unit testing also provides documentation on how a function is expected to behave

-> pytest and unittest
  -> there are two primary testing frameworks used in python:
    -> `pytest`
    -> `unittest`
  -> `pytest` is the more advanced and widely used framework. it provides many features such as better assertion introspection, easy-to-write test cases, and powerful test discovery
  -> `pytest` has a simpler syntax and is often used for quick, simple tests
  -> `unittest` is python's built-in testing framework, which is more verbose and object-oriented but still widely used
  -> both frameworks can test python code, but `pytest` is generally preferred due to its flexibility and ease of use
  -> to use `pytest`, you need to install it first. run this command in your terminal:
    ```bash
    pip install pytest
    ```

-> example test code:
  -> let's see a simple example to understand how unit testing works with `pytest`:
    1. create a python file (e.g., `test_file.py`)
    2. in the file, write a function that you want to test
    3. write a test function that calls the function and checks if the output is correct
    example:
    ```python
    # contents of test_file.py

    def add(a, b):
        return a + b

    def test_add():
        assert add(3, 5) == 8
    ```
  -> the `add()` function simply adds two numbers, and the `test_add()` function checks if adding `3` and `5` results in `8`
  -> to run the test, navigate to the directory where `test_file.py` is located and run:
    ```bash
    pytest test_file.py
    ```
  -> `pytest` will automatically find the test, execute it, and display the results in the terminal
  -> the output will show whether the test passed or failed

-> testing with pytest
  -> if the function was modified, for example, if it incorrectly returned `a + b - 1`, the test would fail
  example of a modified function:
  ```python
  def add(a, b):
      return a + b - 1

-> running the same test with this modified code would produce the following output:
=================== failures ======================
test_file.py::test_add
assert 7 == 8
=================== 1 failed in 0.12s =====================

-> pytest shows that the test failed because add(3, 5) now returns 7 instead of the expected value 8
-> the output includes details about the failure, such as the assertion error and the expected vs actual result
-> this is a great way to catch errors during development, as it shows you exactly where your code went wrong

-> why unit testing is important
-> unit testing helps ensure your code is reliable by testing individual parts in isolation
-> by running tests frequently, you can identify bugs early and fix them quickly
-> unit tests are a form of "self-documentation" ' they show how each function is supposed to behave
-> tests also serve as a safety net when making changes to the codebase. if you modify a function and forget to update its tests, running the tests will help you spot any discrepancies
-> in larger flask apps, unit tests are essential for maintaining a stable and reliable application

-> best practices for unit testing
-> write tests for each function, method, or unit of code
-> keep tests isolated from other parts of the application to avoid dependencies
-> name test functions with a consistent and descriptive naming convention (e.g., test_function_name)
-> make sure tests cover both expected and unexpected inputs to ensure robustness
-> test edge cases and error handling (e.g., what happens if the function receives none or an empty list?)
-> run your tests frequently to catch bugs early in the development process

-> summary: python flask unit testing
-> unit testing is essential for catching bugs early and ensuring the reliability of your flask app
-> pytest is a great testing framework for writing simple, powerful tests in python
-> unit tests test individual units (such as functions) of your code to ensure they work as expected
-> with pytest, you can quickly write tests and run them to verify that your code is functioning correctly
-> unit tests help improve code quality, increase confidence in your app, and make debugging easier
-> in the next lesson, you will learn how to use pytest to test more complex flask applications and set up tests for different parts of your app
