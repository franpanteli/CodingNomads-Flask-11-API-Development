-> introduction to testing your app lesson  
   -> using pytest fixtures to test your flask app  

-> introduction  
   -> in this lesson, you will learn how to use pytest fixtures to create reusable chunks of test code that can be easily used across multiple test functions in your flask app  
   -> fixtures allow you to set up preconditions for your tests and clean up afterwards, ensuring your tests run in a consistent, isolated environment  

-> what is a test fixture?  
   -> a test fixture is a piece of code that sets up a necessary environment for your tests, preparing everything your test will need before it runs  
   -> a fixture is defined as "a software test fixture sets up a system for the software testing process by initialising it, thereby satisfying any preconditions the system may have"  
   -> the primary purpose of a fixture is to make sure that your tests can execute reliably and produce consistent, repeatable results  
   -> fixtures not only help with setting things up but also help to tear them down (i.e., clean up after the tests have run)  

-> pytest fixtures  
   -> pytest fixtures are functions, but these functions are special—they must be decorated with the `@pytest.fixture` decorator  
   -> once defined, a fixture can be injected into test functions by simply adding it as a parameter  
   -> example:  
     ```python  
     @pytest.fixture  
     def my_list():  
         return [3, 4, 7, 8]  
     def test_3_in_list(my_list):  
         assert 3 in my_list  
     ```  
   -> in this example, `my_list()` is a fixture that returns a list of numbers. the test function `test_3_in_list()` takes `my_list` as a parameter and checks if the number 3 is in the list  
   -> pytest automatically "injects" the fixture into the test function by matching the fixture's name to the test function's parameter  

-> how does pytest know what to do?  
   -> pytest looks for functions decorated with `@pytest.fixture`  
   -> when a test function declares a fixture as a parameter, pytest looks for a fixture with the matching name and passes it to the test function  
   -> the test function then uses the value returned by the fixture, as if it was defined locally within the test function  

-> pytest fixture scope  
   -> the scope of a fixture controls how long the fixture lasts and how often it is set up and torn down  
   -> scope can be defined for a fixture and can be one of the following:  
      -> function scope: the fixture is set up and torn down once for each test function that uses it  
      -> class scope: the fixture is set up and torn down once for each test class  
      -> module scope: the fixture is set up and torn down once per module (i.e., once for each python file of tests)  
      -> session scope: the fixture is set up and torn down only once for the entire test session (i.e., across all modules)  
   -> example of scope:  
     ```python  
     @pytest.fixture(scope="module")  
     def my_list():  
         return [3, 4, 7, 8]  
     ```  
   -> in this example, `my_list()` would be created once at the start of the test module and used in all the test functions within that module  
   -> a fixture with function scope will be re-initialised for each individual test function  

-> the `conftest.py` file  
   -> when you have multiple test files and you want to share fixtures across them, it is useful to store your fixtures in a special file called `conftest.py`  
   -> the `conftest.py` file can hold fixtures that will be accessible to all tests in the directory (and subdirectories) where `conftest.py` is located  
   -> you don’t need to explicitly import fixtures from `conftest.py`—pytest will automatically find and use them in your tests  
   -> example file structure:  
     ```  
     tests/  
     ├── conftest.py  # fixtures are defined here  
     ├── test_file_1.py  
     └── test_file_2.py  
     ```  

-> setup and tear down  
   -> a fixture doesn’t just set up resources for your tests—it can also tear them down after the tests complete, ensuring the environment is cleaned up  
   -> this is particularly important when working with databases or files, as you want to make sure each test starts with a clean slate  
   -> you can use the `yield` keyword in your fixture to handle tear down after the test function has completed  
   -> example of a fixture with setup and tear down:  
     ```python  
     @pytest.fixture  
     def order():  
         diner_order = DinerOrder()  # setup  
         yield diner_order  # provide the order to the test  
         diner_order.cleanup()  # tear down  
     ```  
   -> in this example, the fixture sets up the `diner_order` object and then, after the test has finished, it cleans up by calling `cleanup()`  

-> rethinking the database insertion test  
   -> now that you've learned about fixtures, you can refactor previous database-related tests to use fixtures for setup and tear down  
   -> example of a fixture that sets up a flask app instance and database:  
     ```python  
     @pytest.fixture(scope='module')  
     def new_app():  
         app = create_app('testing')  
         assert 'data-test.sqlite' in app.config['SQLALCHEMY_DATABASE_URI']  
         test_client = app.test_client()  
         ctx = app.app_context()  
         ctx.push()  
         db.create_all()  # setup  
         yield test_client  # provide the app's test client to the test function  
         db.session.remove()  # tear down  
         db.drop_all()  
         ctx.pop()  
     ```  
   -> this fixture creates a flask app for testing, sets up the database, and tears down both after the test completes  

-> using the fixture in tests  
   -> after defining the `new_app` fixture, you can use it in your tests by passing it as a parameter to the test function  
   -> example of a test function using the fixture:  
     ```python  
     def test_database_insert(new_app):  
         u = User(email='john@example.com', username='john')  
         db.session.add(u)  
         db.session.commit()  
     ```  
   -> in this example, `new_app` is passed to the test function, and pytest injects the fixture automatically  

-> database insertion test revisited  
   -> with the new fixture, the database insertion test becomes cleaner and more efficient  
   -> the fixture takes care of setting up the app, database, and context, while the test itself focuses on inserting data into the database  

-> more tests to come  
   -> this is just the beginning! as you continue to build your flask app, you'll write more tests, and using fixtures will help you keep your tests clean, organised, and reusable  
   -> a tested app is a reliable app!  

-> summary: pytest fixtures  
   -> test fixtures are functions used to set up and tear down the test environment  
   -> they can be decorated with `@pytest.fixture` and are passed automatically to test functions  
   -> fixtures have different scopes: function, class, module, session  
   -> `conftest.py` allows fixtures to be shared across multiple test files in the same directory  
   -> fixtures can handle both setup and tear down with `yield`  
   -> you learned how to create a fixture to set up and tear down the flask app context and test database  